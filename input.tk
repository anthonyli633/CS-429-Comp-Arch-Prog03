.code
:start
	clr r1                 ; r1 = 0
	addi r1, 5             ; r1 = 5
	addi r2, 10            ; r2 = 10
	add r3, r1, r2         ; r3 = 15

	sub r4, r3, r1         ; r4 = 10
	mul r5, r4, r1         ; r5 = 50
	div r6, r5, r1         ; r6 = 10

	and r7, r5, r6
	or  r8, r5, r6
	xor r9, r5, r6
	not r10, r9

	shftli r11, 3
	shftri r11, 1

	shftl r12, r11, r1
	shftr r13, r12, r1

	br r13                 ; branch to r13 (register-based)

:io_test
	in r14, r1
	out r14, r1

; -------------------------
; Stack operations
; -------------------------
	push r3
	push r4
	pop r15
	pop r16

; -------------------------
; Memory operations
; -------------------------
	mov (r31)(-8), r3      ; store
	mov r17, (r31)(-8)     ; load

; -------------------------
; Floating point ops
; -------------------------
	addf r18, r17, r3
	subf r19, r18, r3
	mulf r20, r19, r3
	divf r21, r20, r3

; -------------------------
; Branch tests
; -------------------------
	brnz r21, r1
	brgt r21, r20, r19

	brr r0                 ; register branch
	brr :end               ; label branch

	addi r22, 1            ; should be skipped

:end
; -------------------------
; Load 64-bit literal
; -------------------------
	ld r23, 0x123456789ABCDEF0

; -------------------------
; More memory ops with offsets
; -------------------------
	mov (r31)(0), r23
	mov r24, (r31)(0)

; -------------------------
; Final I/O and halt
; -------------------------
	out r24, r1
	halt

; =========================
; Data section
; =========================
.data
	0
	1
	42
	1024
	65535
	4294967295
	18446744073709551615